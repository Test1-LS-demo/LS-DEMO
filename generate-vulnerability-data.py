#!/usr/bin/env python3
"""
Generate realistic vulnerability data for ASPM testing
This script creates actual vulnerability scan results that can be imported into ASPM tools
"""

import json
import os
from datetime import datetime, timedelta
import random

def generate_vulnerability_data():
    """Generate realistic vulnerability data for cross-application testing"""
    
    # Base vulnerability data with real CVEs and known vulnerable packages
    vulnerabilities = [
        {
            "cve": "CVE-2022-24999",
            "package": "express",
            "version": "4.16.4",
            "severity": "High",
            "description": "Prototype pollution vulnerability in Express.js",
            "cvss_score": 7.5,
            "owasp_category": "A06: Vulnerable Components",
            "repositories": ["juice-shop", "NodeGoat", "LS-DEMO"],
            "status": "Open"
        },
        {
            "cve": "CVE-2021-3749",
            "package": "axios",
            "version": "0.19.2",
            "severity": "High",
            "description": "Server-Side Request Forgery (SSRF) in Axios",
            "cvss_score": 7.2,
            "owasp_category": "A06: Vulnerable Components",
            "repositories": ["juice-shop", "NodeGoat", "LS-DEMO"],
            "status": "Open"
        },
        {
            "cve": "CVE-2018-1000656",
            "package": "flask",
            "version": "1.0.2",
            "severity": "Critical",
            "description": "Authentication bypass vulnerability in Flask",
            "cvss_score": 9.1,
            "owasp_category": "A07: Identification and Authentication Failures",
            "repositories": ["LS-DEMO"],
            "status": "Open"
        },
        {
            "cve": "CVE-2021-35042",
            "package": "django",
            "version": "1.11.29",
            "severity": "High",
            "description": "SQL injection vulnerability in Django",
            "cvss_score": 8.1,
            "owasp_category": "A03: Injection",
            "repositories": ["LS-DEMO"],
            "status": "Open"
        },
        {
            "cve": "CVE-2020-35653",
            "package": "pillow",
            "version": "6.2.2",
            "severity": "High",
            "description": "Buffer overflow in Pillow image processing",
            "cvss_score": 7.8,
            "owasp_category": "A06: Vulnerable Components",
            "repositories": ["LS-DEMO"],
            "status": "Open"
        },
        {
            "cve": "CVE-2022-24998",
            "package": "express",
            "version": "4.16.4",
            "severity": "Medium",
            "description": "Denial of Service vulnerability in Express.js",
            "cvss_score": 5.3,
            "owasp_category": "A06: Vulnerable Components",
            "repositories": ["juice-shop", "NodeGoat"],
            "status": "Open"
        },
        {
            "cve": "CVE-2021-3748",
            "package": "axios",
            "version": "0.19.2",
            "severity": "Medium",
            "description": "Information disclosure in Axios",
            "cvss_score": 4.7,
            "owasp_category": "A06: Vulnerable Components",
            "repositories": ["juice-shop", "NodeGoat"],
            "status": "Open"
        }
    ]
    
    # Generate repository-specific vulnerability data
    repository_data = {
        "LS-DEMO": {
            "vulnerabilities": [
                v for v in vulnerabilities if "LS-DEMO" in v["repositories"]
            ],
            "scan_date": "2024-01-15T10:30:00Z",
            "total_vulnerabilities": 4,
            "critical": 1,
            "high": 3,
            "medium": 0,
            "low": 0
        },
        "juice-shop": {
            "vulnerabilities": [
                v for v in vulnerabilities if "juice-shop" in v["repositories"]
            ],
            "scan_date": "2024-01-15T11:15:00Z",
            "total_vulnerabilities": 4,
            "critical": 0,
            "high": 2,
            "medium": 2,
            "low": 0
        },
        "NodeGoat": {
            "vulnerabilities": [
                v for v in vulnerabilities if "NodeGoat" in v["repositories"]
            ],
            "scan_date": "2024-01-15T12:00:00Z",
            "total_vulnerabilities": 4,
            "critical": 0,
            "high": 2,
            "medium": 2,
            "low": 0
        },
        "WebGoat": {
            "vulnerabilities": [
                {
                    "cve": "CVE-2021-44228",
                    "package": "log4j",
                    "version": "2.14.1",
                    "severity": "Critical",
                    "description": "Log4Shell vulnerability in Log4j",
                    "cvss_score": 10.0,
                    "owasp_category": "A06: Vulnerable Components",
                    "repositories": ["WebGoat"],
                    "status": "Open"
                }
            ],
            "scan_date": "2024-01-15T12:45:00Z",
            "total_vulnerabilities": 1,
            "critical": 1,
            "high": 0,
            "medium": 0,
            "low": 0
        },
        "mutillidae": {
            "vulnerabilities": [
                {
                    "cve": "CVE-2021-44228",
                    "package": "log4j",
                    "version": "2.14.1",
                    "severity": "Critical",
                    "description": "Log4Shell vulnerability in Log4j",
                    "cvss_score": 10.0,
                    "owasp_category": "A06: Vulnerable Components",
                    "repositories": ["mutillidae"],
                    "status": "Open"
                }
            ],
            "scan_date": "2024-01-15T13:30:00Z",
            "total_vulnerabilities": 1,
            "critical": 1,
            "high": 0,
            "medium": 0,
            "low": 0
        }
    }
    
    return vulnerabilities, repository_data

def create_sarif_files(vulnerabilities, repository_data):
    """Create SARIF files for each repository"""
    
    for repo_name, data in repository_data.items():
        sarif_data = {
            "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
            "version": "2.1.0",
            "runs": [
                {
                    "tool": {
                        "driver": {
                            "name": "Trivy",
                            "version": "0.45.0",
                            "informationUri": "https://github.com/aquasecurity/trivy"
                        }
                    },
                    "results": []
                }
            ]
        }
        
        for vuln in data["vulnerabilities"]:
            result = {
                "ruleId": vuln["cve"],
                "level": "error" if vuln["severity"] == "Critical" else "warning",
                "message": {
                    "text": vuln["description"]
                },
                "locations": [
                    {
                        "physicalLocation": {
                            "artifactLocation": {
                                "uri": f"{repo_name}/package.json"
                            }
                        }
                    }
                ],
                "properties": {
                    "security-severity": vuln["cvss_score"],
                    "package": vuln["package"],
                    "version": vuln["version"],
                    "severity": vuln["severity"],
                    "cve": vuln["cve"],
                    "owasp_category": vuln["owasp_category"]
                }
            }
            sarif_data["runs"][0]["results"].append(result)
        
        # Write SARIF file
        sarif_filename = f"{repo_name}-security-scan.sarif"
        with open(sarif_filename, 'w') as f:
            json.dump(sarif_data, f, indent=2)
        print(f"Created {sarif_filename}")

def create_json_reports(vulnerabilities, repository_data):
    """Create JSON vulnerability reports for each repository"""
    
    for repo_name, data in repository_data.items():
        report_data = {
            "repository": repo_name,
            "scan_date": data["scan_date"],
            "summary": {
                "total_vulnerabilities": data["total_vulnerabilities"],
                "critical": data["critical"],
                "high": data["high"],
                "medium": data["medium"],
                "low": data["low"]
            },
            "vulnerabilities": data["vulnerabilities"]
        }
        
        # Write JSON report
        json_filename = f"{repo_name}-security-scan-results.json"
        with open(json_filename, 'w') as f:
            json.dump(report_data, f, indent=2)
        print(f"Created {json_filename}")

def create_cross_application_summary(vulnerabilities):
    """Create cross-application vulnerability summary"""
    
    # Group vulnerabilities by CVE to show cross-application impact
    cve_groups = {}
    for vuln in vulnerabilities:
        cve = vuln["cve"]
        if cve not in cve_groups:
            cve_groups[cve] = {
                "cve": cve,
                "severity": vuln["severity"],
                "description": vuln["description"],
                "cvss_score": vuln["cvss_score"],
                "owasp_category": vuln["owasp_category"],
                "affected_repositories": vuln["repositories"],
                "package": vuln["package"],
                "version": vuln["version"]
            }
        else:
            # Merge repositories
            cve_groups[cve]["affected_repositories"].extend(vuln["repositories"])
            cve_groups[cve]["affected_repositories"] = list(set(cve_groups[cve]["affected_repositories"]))
    
    # Filter for cross-application vulnerabilities (affecting 2+ repositories)
    cross_app_vulns = {
        cve: data for cve, data in cve_groups.items() 
        if len(data["affected_repositories"]) > 1
    }
    
    summary = {
        "cross_application_vulnerabilities": cross_app_vulns,
        "total_cross_app_vulns": len(cross_app_vulns),
        "repositories_affected": list(set([
            repo for vuln in cross_app_vulns.values() 
            for repo in vuln["affected_repositories"]
        ])),
        "generated_at": datetime.now().isoformat()
    }
    
    with open("cross-application-vulnerabilities.json", 'w') as f:
        json.dump(summary, f, indent=2)
    print("Created cross-application-vulnerabilities.json")

def main():
    """Main function to generate all vulnerability data"""
    print("🔍 Generating vulnerability data for ASPM testing...")
    
    # Generate vulnerability data
    vulnerabilities, repository_data = generate_vulnerability_data()
    
    # Create SARIF files
    print("\n📄 Creating SARIF files...")
    create_sarif_files(vulnerabilities, repository_data)
    
    # Create JSON reports
    print("\n📊 Creating JSON vulnerability reports...")
    create_json_reports(vulnerabilities, repository_data)
    
    # Create cross-application summary
    print("\n🔗 Creating cross-application vulnerability summary...")
    create_cross_application_summary(vulnerabilities)
    
    print("\n✅ Vulnerability data generation complete!")
    print("\nFiles created:")
    print("- [repo-name]-security-scan.sarif (SARIF files for each repository)")
    print("- [repo-name]-security-scan-results.json (JSON reports for each repository)")
    print("- cross-application-vulnerabilities.json (Cross-application summary)")
    
    print("\n🎯 Cross-application vulnerabilities identified:")
    cross_app_vulns = [v for v in vulnerabilities if len(v["repositories"]) > 1]
    for vuln in cross_app_vulns:
        print(f"- {vuln['cve']}: {vuln['package']} {vuln['version']} ({vuln['severity']}) - affects {', '.join(vuln['repositories'])}")

if __name__ == "__main__":
    main()
